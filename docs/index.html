<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Prolific: Git Active</title>
    <style>
      :root { color-scheme: dark; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: radial-gradient(1200px 800px at 30% 20%, #171a22 0%, #0b0c10 45%, #07080b 100%);
        color: #e7e9ee;
        overflow-x: hidden;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 10;
        backdrop-filter: blur(10px);
        background: color-mix(in srgb, #0b0c10 82%, transparent);
        border-bottom: 1px solid color-mix(in srgb, #fff 10%, transparent);
      }
      .topbar {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
        align-items: center;
        justify-content: space-between;
        padding: 14px 18px;
      }
      .brand { display: flex; gap: 12px; align-items: baseline; }
      h1 { font-size: 16px; margin: 0; letter-spacing: 0.2px; }
      .sub { opacity: 0.75; font-size: 13px; }
      .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      select, button {
        padding: 7px 10px;
        border-radius: 10px;
        border: 1px solid color-mix(in srgb, #fff 14%, transparent);
        background: color-mix(in srgb, #0b0c10 65%, transparent);
        color: #e7e9ee;
        cursor: pointer;
      }
      button:hover { border-color: color-mix(in srgb, #fff 22%, transparent); }
      .pill {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid color-mix(in srgb, #fff 14%, transparent);
        opacity: 0.85;
        font-size: 12px;
      }
      .stage {
        position: fixed;
        inset: 0;
        z-index: 0;
      }
      canvas {
        position: absolute;
        inset: 0;
        display: block;
        width: 100%;
        height: 100%;
      }
      .hint {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 12px;
        opacity: 0.65;
        max-width: min(720px, calc(100vw - 36px));
        line-height: 1.35;
      }
      .tooltip {
        position: fixed;
        pointer-events: none;
        background: color-mix(in srgb, #0b0c10 85%, transparent);
        color: #e7e9ee;
        border: 1px solid color-mix(in srgb, #fff 16%, transparent);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        max-width: 420px;
        display: none;
        box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid color-mix(in srgb, #fff 18%, transparent);
        margin-right: 8px;
        opacity: 0.9;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="topbar">
        <div class="brand">
          <h1>Prolific: Git Active</h1>
          <div class="sub">Project systems (metadata only, no file content reads)</div>
        </div>
        <div class="controls">
          <button id="reload">Reload</button>
          <div class="pill" id="count"></div>
          <div class="pill" id="ver">viz v3</div>
        </div>
      </div>
    </header>

    <div class="stage">
      <canvas id="c"></canvas>
      <div class="hint">
        Scroll for parallax depth. Big bubbles are projects (watch folders). Smaller bubbles are activity events and per-language satellites.
        Nothing here includes file names/paths or file contentsâ€”only aggregates by extension and size deltas.
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
      // Visualization version: 2 (project systems + parallax)
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      const tooltip = document.getElementById('tooltip');
      const countEl = document.getElementById('count');
      const verEl = document.getElementById('ver');
      const METRIC = 'net_loc_estimate'; // fixed metric for bubble sizing (keep UI simple)
      if (verEl) verEl.textContent = 'viz v3';

      function clamp(v, lo, hi) {
        const n = Number(v);
        if (!Number.isFinite(n)) return lo;
        return Math.max(lo, Math.min(hi, n));
      }
      function lerp(a, b, t) { return a + (b - a) * t; }

      function parseEventTime(e) {
        const s = String(e.event_id || '');
        const d = new Date(s);
        return isNaN(d.getTime()) ? new Date(0) : d;
      }

      function fmt(n) {
        if (typeof n !== 'number') return String(n);
        const abs = Math.abs(n);
        if (abs >= 1e9) return (n/1e9).toFixed(1) + 'B';
        if (abs >= 1e6) return (n/1e6).toFixed(1) + 'M';
        if (abs >= 1e3) return (n/1e3).toFixed(1) + 'K';
        return String(Math.round(n));
      }

      function num(v, fallback=0) {
        const n = Number(v);
        return Number.isFinite(n) ? n : fallback;
      }

      function hashColor(str) {
        // stable, vibrant-ish color from string (language/asset type)
        let h = 2166136261;
        for (let i=0; i<str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        const hue = Math.abs(h) % 360;
        return `hsl(${hue} 75% 60%)`;
      }

      function rgba(hexOrHsl, a) {
        // Use CSS color-mix fallback by drawing with globalAlpha instead.
        return hexOrHsl;
      }

      const langColor = (lang) => {
        if (!lang) return '#7a7f8a';
        if (lang === 'Assets') return '#a9b1bc';
        return hashColor(lang);
      };

      // Scene state
      let eventsCache = [];
      let nodes = [];   // {id,type,label,x,y,z,vx,vy,r,color,meta,locked}
      let links = [];   // {a,b,rest,k}
      let stars = [];
      let lastT = performance.now();
      let mouse = { x: 0, y: 0, down: false };
      let hovered = null;
      let DPR = 1;
      let CSS_W = 0;
      let CSS_H = 0;

      function resize() {
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const rect = canvas.getBoundingClientRect();
        const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth || 1));
        const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight || 1));
        const w = Math.max(1, Math.floor(cssW * dpr));
        const h = Math.max(1, Math.floor(cssH * dpr));
        DPR = dpr;
        CSS_W = cssW;
        CSS_H = cssH;
        canvas.width = w;
        canvas.height = h;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function scrollY() {
        return window.scrollY || 0;
      }

      function ensureStars() {
        const w = CSS_W || canvas.clientWidth || 1;
        const h = CSS_H || canvas.clientHeight || 1;
        const target = Math.floor((w*h) / 18000);
        if (stars.length >= target) return;
        for (let i=stars.length; i<target; i++) {
          stars.push({
            x: Math.random() * w,
            y: Math.random() * h,
            z: lerp(0.15, 0.9, Math.random()),
            r: lerp(0.6, 1.6, Math.random()),
            a: lerp(0.08, 0.25, Math.random()),
          });
        }
      }

      function buildScene(events) {
        events = [...events].sort((a, b) => parseEventTime(a) - parseEventTime(b));
        eventsCache = events;
        countEl.textContent = `${events.length} event${events.length === 1 ? '' : 's'}`;

        nodes = [];
        links = [];

        // Build "project cores"
        const projectLabels = new Map(); // label -> id
        for (const e of events) {
          const wfs = Array.isArray(e.watch_folders) ? e.watch_folders : [];
          for (const w of wfs) {
            const label = String(w || 'project');
            if (!projectLabels.has(label)) {
              projectLabels.set(label, `p:${label}`);
            }
          }
        }
        if (projectLabels.size === 0) {
          projectLabels.set('project', 'p:project');
        }

        const projects = [...projectLabels.entries()];
        const w = CSS_W || canvas.clientWidth || 1;
        const h = CSS_H || canvas.clientHeight || 1;
        const baseX = w * 0.5;
        const spread = Math.min(520, w * 0.7);
        projects.forEach(([label, id], idx) => {
          const t = projects.length <= 1 ? 0.5 : idx / (projects.length - 1);
          nodes.push({
            id,
            type: 'project',
            label,
            x: baseX + (t - 0.5) * spread,
            y: h * 0.45,
            z: lerp(0.25, 0.7, Math.random()),
            vx: 0, vy: 0,
            r: 40,
            color: '#7cf2c5',
            meta: {},
            locked: false,
          });
        });

        // Vertical "scroll depth" mapping (events down the page)
        const times = events.map(e => parseEventTime(e).getTime());
        const tMin = Math.min(...times, Date.now());
        const tMax = Math.max(...times, Date.now());
        const span = Math.max(1, tMax - tMin);

        // Make page scrollable proportional to history length.
        const days = Math.max(1, Math.ceil(span / (24*3600*1000)));
        const worldHeight = clamp(days * 520, 900, 8000);
        document.body.style.height = `${Math.max(window.innerHeight, worldHeight + 120)}px`;

        const metric = METRIC;
        let maxAbs = 1;
        for (const e of events) {
          maxAbs = Math.max(maxAbs, Math.abs(num(e?.[metric], 0)));
        }

        function addNode(n) { nodes.push(n); return n; }
        function addLink(a, b, rest, k) { links.push({ a, b, rest, k }); }
        function getNode(id) { return nodes.find(n => n.id === id); }

        // Event + satellites
        events.forEach((e, idx) => {
          const metricVal = num(e?.[metric], 0);
          const vAbs = Math.abs(metricVal);
          const tNorm = (parseEventTime(e).getTime() - tMin) / span;

          const y = lerp(window.innerHeight * 0.25, worldHeight, tNorm);
          const orbit = lerp(90, 170, Math.random());
          const theta = (idx * 1.7) % (Math.PI * 2);

          const watchFolders = Array.isArray(e.watch_folders) && e.watch_folders.length ? e.watch_folders : ['project'];
          // Attach to first project label (simple). If multiple, we "fan" by small offsets.
          watchFolders.forEach((wf, j) => {
            const projectId = projectLabels.get(String(wf)) || `p:${String(wf)}`;
            const pNode = getNode(projectId) || getNode('p:project');
            if (!pNode) return;

            const eventId = `e:${e.event_id}:${j}`;
            const r = 10 + Math.sqrt(vAbs / maxAbs) * 24;
            const ev = addNode({
              id: eventId,
              type: 'event',
              label: String(e.event_id || ''),
              x: pNode.x + Math.cos(theta + j*0.6) * orbit,
              y,
              z: lerp(0.35, 1.0, Math.random()),
              vx: 0, vy: 0,
              r,
              color: metricVal >= 0 ? '#2bffb3' : '#ff4d6d',
              meta: { event: e },
              locked: false,
            });
            addLink(pNode.id, ev.id, orbit, 0.015);

            // Satellites by language (top 4 by abs delta bytes)
            const langs = Array.isArray(e.languages) ? e.languages : [];
            const top = [...langs]
              .sort((a,b) => Math.abs(num(b?.delta_bytes, 0)) - Math.abs(num(a?.delta_bytes, 0)))
              .slice(0, 4);

            const satOrbit = lerp(34, 62, Math.random());
            top.forEach((l, k) => {
              const lang = String(l.language || 'Unknown');
                const delta = num(l?.delta_bytes, 0);
              const rr = 6 + Math.sqrt(Math.abs(delta) / Math.max(1, maxAbs)) * 10;
              const sid = `s:${eventId}:${lang}:${k}`;
              const a = theta + 1.3 + k * (Math.PI * 2 / Math.max(3, top.length));
              const sn = addNode({
                id: sid,
                type: 'sat',
                label: lang,
                x: ev.x + Math.cos(a) * satOrbit,
                y: ev.y + Math.sin(a) * satOrbit,
                z: lerp(0.55, 1.0, Math.random()),
                vx: 0, vy: 0,
                r: rr,
                color: langColor(lang),
                meta: { delta_bytes: delta, parent: eventId },
                locked: false,
              });
              addLink(ev.id, sn.id, satOrbit, 0.03);
            });

            // Asset satellite if unknown bytes changed
            const unknown = num(e?.unknown_delta_bytes, 0);
            if (unknown !== 0) {
              const rr = 7 + Math.sqrt(Math.abs(unknown) / Math.max(1, maxAbs)) * 10;
              const a = theta - 1.1;
              const sid = `s:${eventId}:Assets`;
              const sn = addNode({
                id: sid,
                type: 'sat',
                label: 'Assets',
                x: ev.x + Math.cos(a) * (satOrbit + 12),
                y: ev.y + Math.sin(a) * (satOrbit + 12),
                z: lerp(0.55, 1.0, Math.random()),
                vx: 0, vy: 0,
                r: rr,
                color: langColor('Assets'),
                meta: { delta_bytes: unknown, parent: eventId },
                locked: false,
              });
              addLink(ev.id, sn.id, satOrbit + 12, 0.03);
            }
          });
        });
      }

      function applyPhysics(dt) {
        const w = CSS_W || canvas.clientWidth || 1;
        const h = CSS_H || canvas.clientHeight || 1;
        const centerX = w * 0.5;

        // Mild global forces + noise
        for (const n of nodes) {
          if (n.locked) continue;
          // keep within view bounds (soft)
          const bx = clamp(n.x, 40, w - 40);
          const by = clamp(n.y, 60, (document.body.scrollHeight || h) - 60);
          n.vx += (bx - n.x) * 0.002;
          n.vy += (by - n.y) * 0.002;

          // slight drift to keep things alive
          const jitter = 0.06;
          n.vx += (Math.random() - 0.5) * jitter;
          n.vy += (Math.random() - 0.5) * jitter;

          // stabilize projects near center horizontally
          if (n.type === 'project') {
            n.vx += (centerX - n.x) * 0.0008;
          }
        }

        // Repulsion (cheap n^2; OK for small datasets)
        for (let i=0; i<nodes.length; i++) {
          for (let j=i+1; j<nodes.length; j++) {
            const a = nodes[i], b = nodes[j];
            const dx = b.x - a.x, dy = b.y - a.y;
            const d2 = dx*dx + dy*dy + 0.0001;
            const minD = (a.r + b.r) * 0.85;
            if (d2 < (minD*minD*10)) {
              const f = 220 / d2; // tuned
              const fx = dx * f, fy = dy * f;
              if (!a.locked) { a.vx -= fx * dt; a.vy -= fy * dt; }
              if (!b.locked) { b.vx += fx * dt; b.vy += fy * dt; }
            }
          }
        }

        // Spring links
        for (const l of links) {
          const a = nodes.find(n => n.id === l.a);
          const b = nodes.find(n => n.id === l.b);
          if (!a || !b) continue;
          const dx = b.x - a.x, dy = b.y - a.y;
          const d = Math.sqrt(dx*dx + dy*dy) || 1;
          const diff = d - l.rest;
          const f = l.k * diff;
          const fx = (dx / d) * f;
          const fy = (dy / d) * f;
          if (!a.locked) { a.vx += fx; a.vy += fy; }
          if (!b.locked) { b.vx -= fx; b.vy -= fy; }
        }

        // Integrate with damping
        const damping = 0.92;
        for (const n of nodes) {
          if (n.locked) continue;
          n.vx *= damping;
          n.vy *= damping;
          n.x += n.vx * 16 * dt;
          n.y += n.vy * 16 * dt;
        }
      }

      function nodeScreenPos(n) {
        // Parallax: deeper nodes move slower with scroll.
        const sy = scrollY();
        const par = clamp(num(n.z, 1.0), 0.25, 1.0);
        return {
          x: n.x,
          // Convert world y to screen y, then apply mild parallax.
          y: (n.y - sy) + (sy * (1 - par) * 0.25),
        };
      }

      function draw() {
        // Safety: if the canvas ended up with a tiny layout box, re-measure/re-size.
        if (canvas.width < 50 || canvas.height < 50) {
          resize();
        }
        const w = CSS_W || window.innerWidth || canvas.clientWidth || 1;
        const h = CSS_H || window.innerHeight || canvas.clientHeight || 1;
        ctx.clearRect(0, 0, w, h);

        // Background stars (parallax)
        ensureStars();
        ctx.save();
        ctx.fillStyle = '#0b0c10';
        ctx.fillRect(0, 0, w, h);
        for (const s of stars) {
          const yy = s.y - scrollY() * (0.25 * s.z);
          const y = ((yy % (h + 50)) + (h + 50)) % (h + 50) - 25;
          ctx.globalAlpha = s.a;
          ctx.fillStyle = '#e7e9ee';
          ctx.beginPath();
          ctx.arc(s.x, y, s.r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();

        // Debug beacon: draw it BELOW the sticky header so it's actually visible.
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(20, 90, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        let drawn = 0;
        let skipped = 0;
        ctx.restore();

        // Links
        ctx.save();
        for (const l of links) {
          const a = nodes.find(n => n.id === l.a);
          const b = nodes.find(n => n.id === l.b);
          if (!a || !b) continue;
          const ap = nodeScreenPos(a);
          const bp = nodeScreenPos(b);
          const alpha = a.type === 'project' || b.type === 'project' ? 0.22 : 0.18;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = '#cfd6e1';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(ap.x, ap.y);
          ctx.lineTo(bp.x, bp.y);
          ctx.stroke();
        }
        ctx.restore();

        // Nodes (high-contrast fallback so bubbles are unmistakable)
        hovered = null;
        const mx = mouse.x, my = mouse.y;
        const drawOrder = [...nodes].sort((a,b) => (a.z - b.z) || (a.r - b.r));
        for (const n of drawOrder) {
          const p = nodeScreenPos(n);
          if (!Number.isFinite(p.x) || !Number.isFinite(p.y) || !Number.isFinite(n.r)) {
            skipped += 1;
            continue;
          }
          const rr = clamp(n.r, 2, 140);

          // Hover detection (screen coords)
          const dx = mx - p.x;
          const dy = my - p.y;
          if ((dx*dx + dy*dy) <= (rr*rr)) {
            hovered = n;
          }

          ctx.save();
          ctx.globalAlpha = 0.92;
          ctx.fillStyle = n.color || '#7cf2c5';
          ctx.beginPath();
          ctx.arc(p.x, p.y, rr, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 0.55;
          ctx.strokeStyle = '#e7e9ee';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
          drawn += 1;
        }

        // Debug text after drawing attempt
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText(`draw() nodes=${nodes.length} drawn=${drawn} skipped=${skipped} canvas=${w}x${h}`, 34, 94);
        ctx.restore();

        // Tooltip
        if (hovered) {
          tooltip.style.display = 'block';
          const n = hovered;
          if (n.type === 'project') {
            tooltip.innerHTML = `<div><span class="badge">Project</span>${n.label}</div>`;
          } else if (n.type === 'event') {
            const e = (n.meta && n.meta.event) ? n.meta.event : {};
            const wf = (e.watch_folders || []).join(', ');
            tooltip.innerHTML = `
              <div><span class="badge">Event</span>${String(e.event_id || '')}</div>
              ${wf ? `<div>project: ${wf}</div>` : ``}
              <div>net_loc=${e.net_loc_estimate}, churn_loc=${e.churn_loc_estimate}, delta_bytes=${e.total_delta_bytes}</div>
              <div>files +${e.counts.files_added} ~${e.counts.files_modified} -${e.counts.files_removed}</div>
            `;
          } else {
            tooltip.innerHTML = `<div><span class="badge">Type</span>${n.label}</div><div>delta_bytes=${fmt(Number(n.meta?.delta_bytes||0))}</div>`;
          }
          tooltip.style.left = (mouse.x + 14) + 'px';
          tooltip.style.top = (mouse.y + 14) + 'px';
        } else {
          tooltip.style.display = 'none';
        }
      }

      function frame(now) {
        const dt = clamp((now - lastT) / 1000, 0.01, 0.05);
        lastT = now;
        applyPhysics(dt);
        draw();
        requestAnimationFrame(frame);
      }

      async function loadEvents() {
        const res = await fetch('./events.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('Failed to load events.json');
        return await res.json();
      }

      async function main() {
        try {
          // Ensure canvas size is correct before building/laying out nodes.
          resize();
          ensureStars();
          const events = await loadEvents();
          buildScene(events);
        } catch (e) {
          countEl.textContent = String(e);
        }
      }

      function wire() {
        window.addEventListener('resize', () => { resize(); ensureStars(); });
        document.getElementById('reload').addEventListener('click', main);
        window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('scroll', () => { /* parallax uses scrollY() */ });
      }

      resize();
      ensureStars();
      wire();
      // Wait one frame so layout is stable before building the scene.
      requestAnimationFrame(main);
      requestAnimationFrame(frame);
    </script>
  </body>
</html>
