<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Prolific: Git Active</title>
    <style>
      :root { color-scheme: dark; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: radial-gradient(1200px 800px at 30% 20%, #171a22 0%, #0b0c10 45%, #07080b 100%);
        color: #e7e9ee;
        overflow-x: hidden;
      }
      header {
        position: sticky;
        top: 0;
        z-index: 10;
        backdrop-filter: blur(10px);
        background: color-mix(in srgb, #0b0c10 82%, transparent);
        border-bottom: 1px solid color-mix(in srgb, #fff 10%, transparent);
      }
      .topbar {
        display: flex;
        flex-wrap: wrap;
        gap: 14px;
        align-items: center;
        justify-content: space-between;
        padding: 14px 18px;
      }
      .brand { display: flex; gap: 12px; align-items: baseline; }
      h1 { font-size: 16px; margin: 0; letter-spacing: 0.2px; }
      .sub { opacity: 0.75; font-size: 13px; }
      .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      select, button {
        padding: 7px 10px;
        border-radius: 10px;
        border: 1px solid color-mix(in srgb, #fff 14%, transparent);
        background: color-mix(in srgb, #0b0c10 65%, transparent);
        color: #e7e9ee;
        cursor: pointer;
      }
      button:hover { border-color: color-mix(in srgb, #fff 22%, transparent); }
      .pill {
        padding: 6px 10px;
        border-radius: 999px;
        border: 1px solid color-mix(in srgb, #fff 14%, transparent);
        opacity: 0.85;
        font-size: 12px;
      }
      .stage {
        position: fixed;
        inset: 0;
        z-index: 0;
      }
      canvas {
        position: absolute;
        inset: 0;
        display: block;
        width: 100%;
        height: 100%;
      }
      .hint {
        position: absolute;
        left: 18px;
        bottom: 14px;
        font-size: 12px;
        opacity: 0.65;
        max-width: min(720px, calc(100vw - 36px));
        line-height: 1.35;
      }
      .tooltip {
        position: fixed;
        pointer-events: none;
        background: color-mix(in srgb, #0b0c10 85%, transparent);
        color: #e7e9ee;
        border: 1px solid color-mix(in srgb, #fff 16%, transparent);
        border-radius: 12px;
        padding: 10px 12px;
        font-size: 12px;
        max-width: 420px;
        display: none;
        box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid color-mix(in srgb, #fff 18%, transparent);
        margin-right: 8px;
        opacity: 0.9;
      }
    </style>
  </head>
  <body>
    <header>
      <div class="topbar">
        <div class="brand">
          <h1>Prolific: Git Active</h1>
          <div class="sub">Project systems (metadata only, no file content reads)</div>
        </div>
        <div class="controls">
          <button id="reload">Reload</button>
          <button id="zoom-out" title="Zoom out">-</button>
          <button id="zoom-reset" title="Reset zoom">100%</button>
          <button id="zoom-in" title="Zoom in">+</button>
          <div class="pill" id="count"></div>
          <div class="pill" id="ver">viz v10</div>
        </div>
      </div>
    </header>

    <div class="stage">
      <canvas id="c"></canvas>
      <div class="hint">
        Scroll for parallax depth. Big bubbles are projects (watch folders). Smaller bubbles are activity events and per-language satellites.
        Nothing here includes file names/paths or file contents—only aggregates by extension and size deltas.
      </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
      // Visualization version: 2 (project systems + parallax)
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      const tooltip = document.getElementById('tooltip');
      const countEl = document.getElementById('count');
      const verEl = document.getElementById('ver');
      const METRIC = 'net_loc_estimate'; // fixed metric for bubble sizing (keep UI simple)
      if (verEl) verEl.textContent = 'viz v10';

      // Zoom state
      let zoomLevel = 1.0; // 1.0 = 100%, can range from 0.1 to 3.0
      let targetZoom = 1.0;
      const ZOOM_MIN = 0.1;
      const ZOOM_MAX = 3.0;
      const ZOOM_STEP = 0.1;
      const ZOOM_SMOOTH = 0.15; // Smooth interpolation factor

      function clamp(v, lo, hi) {
        const n = Number(v);
        if (!Number.isFinite(n)) return lo;
        return Math.max(lo, Math.min(hi, n));
      }
      function lerp(a, b, t) { return a + (b - a) * t; }

      function parseEventTime(e) {
        const s = String(e.event_id || '');
        const d = new Date(s);
        return isNaN(d.getTime()) ? new Date(0) : d;
      }

      function fmt(n) {
        if (typeof n !== 'number') return String(n);
        const abs = Math.abs(n);
        if (abs >= 1e9) return (n/1e9).toFixed(1) + 'B';
        if (abs >= 1e6) return (n/1e6).toFixed(1) + 'M';
        if (abs >= 1e3) return (n/1e3).toFixed(1) + 'K';
        return String(Math.round(n));
      }

      function num(v, fallback=0) {
        const n = Number(v);
        return Number.isFinite(n) ? n : fallback;
      }

      function hashColor(str) {
        // stable, vibrant-ish color from string (language/asset type)
        let h = 2166136261;
        for (let i=0; i<str.length; i++) {
          h ^= str.charCodeAt(i);
          h = Math.imul(h, 16777619);
        }
        const hue = Math.abs(h) % 360;
        return `hsl(${hue} 75% 60%)`;
      }

      function rgba(hexOrHsl, a) {
        // Use CSS color-mix fallback by drawing with globalAlpha instead.
        return hexOrHsl;
      }

      const langColor = (lang) => {
        if (!lang) return '#7a7f8a';
        if (lang === 'Assets') return '#a9b1bc';
        return hashColor(lang);
      };

      // Scene state
      let eventsCache = [];
      let nodes = [];   // {id,type,label,x,y,z,vx,vy,r,color,meta,locked}
      let links = [];   // {a,b,rest,k}
      let stars = [];
      let lastT = performance.now();
      let mouse = { x: 0, y: 0, down: false };
      let hovered = null;
      let DPR = 1;
      let CSS_W = 0;
      let CSS_H = 0;

      function resize() {
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        const rect = canvas.getBoundingClientRect();
        const cssW = Math.max(1, Math.floor(rect.width || window.innerWidth || 1));
        const cssH = Math.max(1, Math.floor(rect.height || window.innerHeight || 1));
        const w = Math.max(1, Math.floor(cssW * dpr));
        const h = Math.max(1, Math.floor(cssH * dpr));
        DPR = dpr;
        CSS_W = cssW;
        CSS_H = cssH;
        canvas.width = w;
        canvas.height = h;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      function scrollY() {
        return window.scrollY || 0;
      }

      function ensureStars() {
        const w = CSS_W || window.innerWidth || canvas.clientWidth || 1;
        const h = CSS_H || window.innerHeight || canvas.clientHeight || 1;
        const target = Math.floor((w*h) / 18000);
        if (stars.length >= target) return;
        for (let i=stars.length; i<target; i++) {
          stars.push({
            x: Math.random() * w,
            y: Math.random() * h,
            z: lerp(0.15, 0.9, Math.random()),
            r: lerp(0.6, 1.6, Math.random()),
            a: lerp(0.08, 0.25, Math.random()),
          });
        }
      }

      function buildScene(events) {
        events = [...events].sort((a, b) => parseEventTime(a) - parseEventTime(b));
        eventsCache = events;
        countEl.textContent = `${events.length} event${events.length === 1 ? '' : 's'}`;

        nodes = [];
        links = [];

        // Build "project cores"
        const projectLabels = new Map(); // label -> id
        for (const e of events) {
          const wfs = Array.isArray(e.watch_folders) ? e.watch_folders : [];
          for (const w of wfs) {
            const label = String(w || 'project');
            if (!projectLabels.has(label)) {
              projectLabels.set(label, `p:${label}`);
            }
          }
        }
        if (projectLabels.size === 0) {
          projectLabels.set('project', 'p:project');
        }

        const projects = [...projectLabels.entries()];
        const w = CSS_W || window.innerWidth || canvas.clientWidth || 1;
        const h = CSS_H || window.innerHeight || canvas.clientHeight || 1;
        
        // Group events by project FIRST to calculate sizes
        const eventsByProject = new Map();
        for (const e of events) {
          const wfs = Array.isArray(e.watch_folders) && e.watch_folders.length ? e.watch_folders : ['project'];
          for (const wf of wfs) {
            const key = String(wf);
            if (!eventsByProject.has(key)) eventsByProject.set(key, []);
            eventsByProject.get(key).push(e);
          }
        }
        
        // Position projects dynamically based on their event counts and orbit sizes
        let currentY = h * 0.3; // Start higher up
        const centerX = w * 0.5;
        
        projects.forEach(([label, id], idx) => {
          const projectEvents = eventsByProject.get(label) || [];
          const eventOrbitRadius = 180; // Fixed orbit radius for events
          const projectSize = 60; // Project core radius
          
          // Each project needs space for: core + orbit + event bubbles (up to 140px) + satellites (~60px)
          const projectSpace = projectSize + eventOrbitRadius + 140 + 60; // ~440px total diameter
          
          // Position this project
          const projectX = centerX;
          const projectY = currentY;
          
          nodes.push({
            id,
            type: 'project',
            label,
            x: projectX,
            y: projectY,
            z: 0.5,
            vx: 0, vy: 0,
            r: projectSize,
            color: '#7cf2c5',
            meta: { 
              projectIdx: idx,
              eventCount: projectEvents.length,
              orbitRadius: 0, // Projects orbit each other
              orbitAngle: (idx / Math.max(projects.length, 1)) * Math.PI * 2,
              orbitSpeed: 0.05 // Rotation speed
            },
            locked: false, // Allow rotation
          });
          
          // Advance Y for next project (add space for this project + gap)
          currentY += projectSpace + 100; // 100px gap between projects
        });
        
        // Set page height based on actual content
        document.body.style.height = `${Math.max(window.innerHeight, currentY + 200)}px`;

        // Group events by project, then position in circular orbits
        const metric = METRIC;
        let maxAbs = 1;
        for (const e of events) {
          maxAbs = Math.max(maxAbs, Math.abs(num(e?.[metric], 0)));
        }

        function addNode(n) { nodes.push(n); return n; }
        function addLink(a, b, rest, k) { links.push({ a, b, rest, k }); }
        function getNode(id) { return nodes.find(n => n.id === id); }

        // Position events in circular orbits around their project cores
        // Process each project separately to distribute events evenly in a full circle
        projects.forEach(([projectLabel, projectId]) => {
          const projectEvents = eventsByProject.get(projectLabel) || [];
          if (projectEvents.length === 0) return;

          const pNode = getNode(projectId);
          if (!pNode) return;

          // Orbit parameters: reasonable orbit radius for events around project core
          const eventOrbitRadius = 180;

          // Distribute THIS project's events evenly in a full 360° circle
          projectEvents.forEach((e, eventIdx) => {
            const metricVal = num(e?.[metric], 0);
            const vAbs = Math.abs(metricVal);
            
            // Calculate angle based on position within THIS project's events
            const theta = (eventIdx / Math.max(projectEvents.length, 1)) * Math.PI * 2;

            const eventId = `e:${e.event_id}:${projectLabel}`;
            const r = 12 + Math.sqrt(vAbs / maxAbs) * 28;
            
            // Position event in circular orbit around THIS project core
            const evX = pNode.x + Math.cos(theta) * eventOrbitRadius;
            const evY = pNode.y + Math.sin(theta) * eventOrbitRadius;
            const ev = addNode({
              id: eventId,
              type: 'event',
              label: String(e.event_id || ''),
              x: evX,
              y: evY,
              z: lerp(0.35, 1.0, Math.random()),
              vx: 0, vy: 0,
              r,
              color: metricVal >= 0 ? '#2bffb3' : '#ff4d6d',
              meta: { 
                event: e,
                parentId: projectId,
                orbitRadius: eventOrbitRadius,
                orbitAngle: theta,
                orbitSpeed: 0.1 // Events rotate around projects
              },
              locked: false,
            });
            // Link with correct rest distance (since we use cos/sin for both X and Y, distance = radius)
            addLink(pNode.id, ev.id, eventOrbitRadius, 0.012);

            // Satellites by language (top 4 by abs delta bytes)
            const langs = Array.isArray(e.languages) ? e.languages : [];
            const top = [...langs]
              .sort((a,b) => Math.abs(num(b?.delta_bytes, 0)) - Math.abs(num(a?.delta_bytes, 0)))
              .slice(0, 4);

            top.forEach((l, k) => {
              const lang = String(l.language || 'Unknown');
                const delta = num(l?.delta_bytes, 0);
              const rr = 6 + Math.sqrt(Math.abs(delta) / Math.max(1, maxAbs)) * 10;
              const sid = `s:${eventId}:${lang}:${k}`;
              // Satellite orbit distance proportional to its size (bigger activity = further orbit)
              const satOrbit = 40 + (rr * 2); // Base distance + 2x the radius
              const a = (k / Math.max(top.length, 1)) * Math.PI * 2;
              const sn = addNode({
                id: sid,
                type: 'sat',
                label: lang,
                x: ev.x + Math.cos(a) * satOrbit,
                y: ev.y + Math.sin(a) * satOrbit,
                z: lerp(0.55, 1.0, Math.random()),
                vx: 0, vy: 0,
                r: rr,
                color: langColor(lang),
                meta: { 
                  delta_bytes: delta,
                  parentId: eventId,
                  orbitRadius: satOrbit,
                  orbitAngle: a,
                  orbitSpeed: 0.2 // Satellites rotate faster around events
                },
                locked: false,
              });
              // Satellite orbits: use calculated satOrbit distance
              addLink(ev.id, sn.id, satOrbit, 0.04);
            });

            // Asset satellite if unknown bytes changed
            const unknown = num(e?.unknown_delta_bytes, 0);
            if (unknown !== 0) {
              const rr = 7 + Math.sqrt(Math.abs(unknown) / Math.max(1, maxAbs)) * 10;
              // Orbit distance proportional to size
              const satOrbit = 40 + (rr * 2);
              const a = (top.length / (top.length + 1)) * Math.PI * 2;
              const sid = `s:${eventId}:Assets`;
              const sn = addNode({
                id: sid,
                type: 'sat',
                label: 'Assets',
                x: ev.x + Math.cos(a) * satOrbit,
                y: ev.y + Math.sin(a) * satOrbit,
                z: lerp(0.55, 1.0, Math.random()),
                vx: 0, vy: 0,
                r: rr,
                color: langColor('Assets'),
                meta: { 
                  delta_bytes: unknown,
                  parentId: eventId,
                  orbitRadius: satOrbit,
                  orbitAngle: a,
                  orbitSpeed: 0.2
                },
                locked: false,
              });
              addLink(ev.id, sn.id, satOrbit, 0.04);
            }
          });
        });
      }

      function applyPhysics(dt) {
        // Apply orbital rotation animations
        for (const n of nodes) {
          if (!n.meta || n.meta.orbitSpeed === undefined) continue;
          
          // Update orbit angle
          n.meta.orbitAngle += n.meta.orbitSpeed * dt;
          
          // Find parent node
          const parent = nodes.find(p => p.id === n.meta.parentId);
          if (!parent) {
            // Projects have no parent - they stay in their base positions
            // (or orbit around a galactic center if we add that later)
            continue;
          }
          
          // Update position based on parent position + orbital rotation
          const radius = n.meta.orbitRadius || 0;
          n.x = parent.x + Math.cos(n.meta.orbitAngle) * radius;
          n.y = parent.y + Math.sin(n.meta.orbitAngle) * radius;
        }
      }

      function nodeScreenPos(n) {
        // Apply zoom transform around viewport center
        const w = CSS_W || window.innerWidth || canvas.clientWidth || 1;
        const h = CSS_H || window.innerHeight || canvas.clientHeight || 1;
        const centerX = w * 0.5;
        const centerY = h * 0.5;
        
        const rawX = num(n.x, centerX);
        const rawY = num(n.y, centerY);
        
        // Zoom around center
        const zoomedX = centerX + (rawX - centerX) * zoomLevel;
        const zoomedY = centerY + (rawY - centerY) * zoomLevel;
        
        return {
          x: zoomedX,
          y: zoomedY,
        };
      }

      function calculateBounds() {
        // Calculate bounding box of all nodes
        if (nodes.length === 0) return { minX: 0, maxX: 1000, minY: 0, maxY: 1000 };
        
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        for (const n of nodes) {
          const x = num(n.x, 0);
          const y = num(n.y, 0);
          // Use the actual clamped radius that will be displayed
          const r = clamp(num(n.r, 20), 2, 140);
          
          minX = Math.min(minX, x - r);
          maxX = Math.max(maxX, x + r);
          minY = Math.min(minY, y - r);
          maxY = Math.max(maxY, y + r);
        }
        
        return { minX, maxX, minY, maxY };
      }

      function autoFitZoom() {
        // Calculate zoom level to fit all nodes in viewport
        const bounds = calculateBounds();
        const w = CSS_W || window.innerWidth || canvas.clientWidth || 1;
        const h = CSS_H || window.innerHeight || canvas.clientHeight || 1;
        
        const contentWidth = bounds.maxX - bounds.minX;
        const contentHeight = bounds.maxY - bounds.minY;
        
        // Add 10% padding
        const scaleX = (w * 0.9) / contentWidth;
        const scaleY = (h * 0.9) / contentHeight;
        
        targetZoom = Math.min(scaleX, scaleY, ZOOM_MAX);
        targetZoom = Math.max(targetZoom, ZOOM_MIN);
      }

      function draw() {
        // Smooth zoom interpolation
        zoomLevel += (targetZoom - zoomLevel) * ZOOM_SMOOTH;
        
        // Safety: if the canvas ended up with a tiny layout box, re-measure/re-size.
        if (canvas.width < 50 || canvas.height < 50) {
          resize();
        }
        const w = CSS_W || window.innerWidth || canvas.clientWidth || 1;
        const h = CSS_H || window.innerHeight || canvas.clientHeight || 1;
        ctx.clearRect(0, 0, w, h);

        // Background stars (parallax)
        ensureStars();
        ctx.save();
        ctx.fillStyle = '#0b0c10';
        ctx.fillRect(0, 0, w, h);
        for (const s of stars) {
          const yy = s.y - scrollY() * (0.25 * s.z);
          const y = ((yy % (h + 50)) + (h + 50)) % (h + 50) - 25;
          ctx.globalAlpha = s.a;
          ctx.fillStyle = '#e7e9ee';
          ctx.beginPath();
          ctx.arc(s.x, y, s.r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();

        // Debug beacon: draw it BELOW the sticky header so it's actually visible.
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(20, 90, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        let drawn = 0;
        let skipped = 0;
        let badX = 0, badY = 0, badR = 0;
        ctx.restore();

        // Links - connect bubble edges, not centers
        ctx.save();
        for (const l of links) {
          const a = nodes.find(n => n.id === l.a);
          const b = nodes.find(n => n.id === l.b);
          if (!a || !b) continue;
          const ap = nodeScreenPos(a);
          const bp = nodeScreenPos(b);
          
          // Calculate vector from a to b
          const dx = bp.x - ap.x;
          const dy = bp.y - ap.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 0.1) continue; // Skip if nodes are at same position
          
          // Normalize and offset by bubble radii to connect at edges
          const ndx = dx / dist;
          const ndy = dy / dist;
          // Scale radii by zoom level like we do when drawing
          const ar = clamp(num(a.r, 20) * zoomLevel, 2, 140);
          const br = clamp(num(b.r, 20) * zoomLevel, 2, 140);
          
          const startX = ap.x + ndx * ar;
          const startY = ap.y + ndy * ar;
          const endX = bp.x - ndx * br;
          const endY = bp.y - ndy * br;
          
          const alpha = a.type === 'project' || b.type === 'project' ? 0.22 : 0.18;
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = '#cfd6e1';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.stroke();
        }
        ctx.restore();

        // Nodes (high-contrast fallback so bubbles are unmistakable)
        hovered = null;
        const mx = mouse.x, my = mouse.y;
        const drawOrder = [...nodes].sort((a,b) => (a.z - b.z) || (a.r - b.r));
        for (const n of drawOrder) {
          const p = nodeScreenPos(n);
          // Use num() to guarantee finite fallbacks (screen center if coord is missing/invalid).
          const px = num(p.x, w * 0.5);
          const py = num(p.y, h * 0.5);
          const nr = num(n.r, 20);
          // These should NEVER fail now, but keep diagnostics just in case.
          if (!Number.isFinite(px)) badX += 1;
          if (!Number.isFinite(py)) badY += 1;
          if (!Number.isFinite(nr)) badR += 1;
          if (!Number.isFinite(px) || !Number.isFinite(py) || !Number.isFinite(nr)) {
            skipped += 1;
            continue;
          }
          // Scale radius by zoom level
          const rr = clamp(nr * zoomLevel, 2, 140);

          // Hover detection (screen coords)
          const dx = mx - p.x;
          const dy = my - p.y;
          if ((dx*dx + dy*dy) <= (rr*rr)) {
            hovered = n;
          }

          ctx.save();
          ctx.globalAlpha = 0.92;
          ctx.fillStyle = n.color || '#7cf2c5';
          ctx.beginPath();
          ctx.arc(px, py, rr, 0, Math.PI * 2);
          ctx.arc(px, py, rr, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 0.55;
          ctx.strokeStyle = '#e7e9ee';
          ctx.lineWidth = 1;
          ctx.stroke();
          ctx.restore();
          drawn += 1;
        }

        // Debug text after drawing attempt
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
        ctx.fillText(
          `draw() nodes=${nodes.length} drawn=${drawn} skipped=${skipped} canvas=${w}x${h}`,
          34,
          94
        );
        ctx.restore();

        // Tooltip
        if (hovered) {
          tooltip.style.display = 'block';
          const n = hovered;
          if (n.type === 'project') {
            tooltip.innerHTML = `<div><span class="badge">Project</span>${n.label}</div>`;
          } else if (n.type === 'event') {
            const e = (n.meta && n.meta.event) ? n.meta.event : {};
            tooltip.innerHTML = `
              <div><span class="badge">Event</span>${String(e.event_id || '')}</div>
              <div>net_loc=${e.net_loc_estimate}, churn_loc=${e.churn_loc_estimate}, delta_bytes=${e.total_delta_bytes}</div>
              <div>files +${e.counts.files_added} ~${e.counts.files_modified} -${e.counts.files_removed}</div>
            `;
          } else {
            tooltip.innerHTML = `<div><span class="badge">Type</span>${n.label}</div><div>delta_bytes=${fmt(Number(n.meta?.delta_bytes||0))}</div>`;
          }
          tooltip.style.left = (mouse.x + 14) + 'px';
          tooltip.style.top = (mouse.y + 14) + 'px';
        } else {
          tooltip.style.display = 'none';
        }
      }

      function frame(now) {
        const dt = clamp((now - lastT) / 1000, 0.01, 0.05);
        lastT = now;
        applyPhysics(dt);
        draw();
        requestAnimationFrame(frame);
      }

      async function loadEvents() {
        const res = await fetch('./events.json', { cache: 'no-store' });
        if (!res.ok) throw new Error('Failed to load events.json');
        return await res.json();
      }

      async function main() {
        try {
          // Ensure canvas size is correct before building/laying out nodes.
          resize();
          ensureStars();
          const events = await loadEvents();
          buildScene(events);
          
          // Auto-fit zoom to show all nodes
          autoFitZoom();
        } catch (e) {
          countEl.textContent = String(e);
        }
      }

      function wire() {
        window.addEventListener('resize', resize);
        
        document.getElementById('reload').addEventListener('click', main);
        
        // Zoom controls
        document.getElementById('zoom-in').addEventListener('click', () => {
          targetZoom = Math.min(targetZoom + ZOOM_STEP, ZOOM_MAX);
        });
        
        document.getElementById('zoom-out').addEventListener('click', () => {
          targetZoom = Math.max(targetZoom - ZOOM_STEP, ZOOM_MIN);
        });
        
        document.getElementById('zoom-reset').addEventListener('click', () => {
          autoFitZoom();
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = -Math.sign(e.deltaY) * ZOOM_STEP;
          targetZoom = clamp(targetZoom + delta, ZOOM_MIN, ZOOM_MAX);
        }, { passive: false });
        
        window.addEventListener('mousemove', (e) => { mouse.x = e.clientX; mouse.y = e.clientY; });
        window.addEventListener('scroll', () => { /* parallax uses scrollY() */ });
      }
      resize();
      ensureStars();
      wire();
      // Wait one frame so layout is stable before building the scene.
      requestAnimationFrame(main);
      requestAnimationFrame(frame);
    </script>
  </body>
</html>
